---
title: events.match_summary()
description: Get aggregated match statistics for an event
icon: pie-chart
---

import { TypeTable } from 'fumadocs-ui/components/type-table';
import { Callout } from 'fumadocs-ui/components/callout';
import { Cards, Card } from 'fumadocs-ui/components/card';
import { ListChecks, Info, CalendarSearch } from 'lucide-react';

## Signature

```python
import vlrdevapi as vlr

result = vlr.events.match_summary(
    event_id: int,
    timeout: float = 5.0
) -> MatchSummary | None
```

## Parameters

<TypeTable
  type={{
    event_id: {
      type: 'int',
      description: 'Unique event identifier',
      required: true,
    },
    timeout: {
      type: 'float',
      description: 'Request timeout in seconds',
      default: '5.0',
    },
  }}
/>

## Return Value

**Type:** `MatchSummary | None`

Returns aggregated match statistics or `None` if not found.

<TypeTable
  type={{
    event_id: {
      type: 'int',
      description: 'Event ID',
      required: true,
    },
    total_matches: {
      type: 'int',
      description: 'Total number of matches',
      required: true,
    },
    completed: {
      type: 'int',
      description: 'Number of completed matches',
      required: true,
    },
    upcoming: {
      type: 'int',
      description: 'Number of upcoming matches',
      required: true,
    },
    ongoing: {
      type: 'int',
      description: 'Number of ongoing matches',
      required: true,
    },
    stages: {
      type: 'list[StageMatches]',
      description: 'Stage-specific match summaries (currently always empty)',
      required: true,
    },
  }}
/>

**StageMatches fields:**

<TypeTable
  type={{
    name: {
      type: 'str',
      description: 'Stage name',
      required: true,
    },
    match_count: {
      type: 'int',
      description: 'Total matches in stage',
      required: true,
    },
    completed: {
      type: 'int',
      description: 'Completed matches in stage',
      required: true,
    },
    upcoming: {
      type: 'int',
      description: 'Upcoming matches in stage',
      required: true,
    },
    ongoing: {
      type: 'int',
      description: 'Ongoing matches in stage',
      required: true,
    },
    start_date: {
      type: 'date | None',
      description: 'Stage start date',
    },
    end_date: {
      type: 'date | None',
      description: 'Stage end date',
    },
  }}
/>

## Examples

### Get Match Summary

```python title="Get match summary"
import vlrdevapi as vlr

# Get match statistics for an event
summary = vlr.events.match_summary(event_id=1189)

if summary:
    print(f"Event ID: {summary.event_id}")
    print(f"Total Matches: {summary.total_matches}")
    print(f"  Completed: {summary.completed}")
    print(f"  Upcoming: {summary.upcoming}")
    print(f"  Ongoing: {summary.ongoing}")
    
    # Calculate completion percentage
    if summary.total_matches > 0:
        completion = (summary.completed / summary.total_matches) * 100
        print(f"\nCompletion: {completion:.1f}%")
else:
    print("Match summary not available")
```

### Monitor Event Progress

```python title="Monitor event progress"
import vlrdevapi as vlr

summary = vlr.events.match_summary(event_id=1189)

if summary:
    # Check if event is active
    if summary.ongoing > 0:
        print(f" LIVE: {summary.ongoing} match(es) in progress")
    
    # Show remaining matches
    remaining = summary.upcoming + summary.ongoing
    if remaining > 0:
        print(f" {remaining} match(es) remaining")
    
    # Event completed
    if summary.completed == summary.total_matches:
        print(" Event completed!")
```

### Track Event Completion Over Time

```python title="Track event completion over time"
import vlrdevapi as vlr
import time

def monitor_event_progress(event_id, interval_seconds=60):
    """Monitor an event's progress over time"""
    print(f"Monitoring event {event_id} every {interval_seconds} seconds...")
    
    last_completed = 0
    
    while True:
        summary = vlr.events.match_summary(event_id)
        
        if not summary:
            print("Event not found or summary unavailable")
            break
        
        if summary.completed != last_completed:
            print(f"Progress update: {summary.completed}/{summary.total_matches} matches completed")
            last_completed = summary.completed
            
            if summary.completed == summary.total_matches:
                print(" Event completed!")
                break
        
        time.sleep(interval_seconds)

# Monitor an active event (run in background)
# monitor_event_progress(1189, 300)  # Check every 5 minutes
```

### Compare Event Sizes

```python title="Compare event sizes"
import vlrdevapi as vlr

def compare_events(event_ids):
    """Compare the scale of different events"""
    comparisons = {}
    
    for event_id in event_ids:
        summary = vlr.events.match_summary(event_id)
        if summary:
            comparisons[event_id] = {
                'total_matches': summary.total_matches,
                'completed': summary.completed,
                'completion_rate': (summary.completed / summary.total_matches * 100) if summary.total_matches > 0 else 0
            }
    
    return comparisons

# Compare multiple events
event_ids = [1189, 1190, 1191]  # Replace with actual event IDs
comparison = compare_events(event_ids)

print("Event Size Comparison:")
print("Event ID | Matches | Completed | Completion Rate")
print("-" * 50)

for event_id, stats in comparison.items():
    rate = f"{stats['completion_rate']:.1f}%"
    print(f"{event_id:8} | {stats['total_matches']:7} | {stats['completed']:9} | {rate:13}")
```

### Create Progress Bar

```python title="Create progress bar"
import vlrdevapi as vlr

def create_progress_bar(event_id, width=50):
    """Create a visual progress bar for event completion"""
    summary = vlr.events.match_summary(event_id)
    
    if not summary:
        return "Event not available"
    
    if summary.total_matches == 0:
        return "No matches scheduled"
    
    # Calculate progress
    progress = summary.completed / summary.total_matches
    filled_width = int(width * progress)
    bar = "#" * filled_width + "-" * (width - filled_width)
    
    percentage = progress * 100
    
    return f"""Event Progress: {summary.completed}/{summary.total_matches} matches
[{bar}] {percentage:.1f}%
Status: {'Completed' if summary.completed == summary.total_matches else f'{summary.ongoing} live, {summary.upcoming} upcoming'}"""

print(create_progress_bar(1189))
```

### Predict Event Duration

```python title="Predict event duration"
import vlrdevapi as vlr
from datetime import datetime, timedelta

def estimate_event_duration(event_id):
    """Estimate how long an event might take based on current progress"""
    summary = vlr.events.match_summary(event_id)
    
    if not summary or summary.total_matches == 0:
        return None
    
    # Get recent matches to estimate pace
    matches = vlr.events.matches(event_id, limit=20)
    
    if not matches:
        return None
    
    # Calculate average matches per day from recent matches
    recent_matches = [m for m in matches if m.date and m.status == "completed"]
    
    if len(recent_matches) < 5:
        return "Not enough data for prediction"
    
    # Group by date
    matches_per_day = {}
    for match in recent_matches:
        date_str = match.date.isoformat()
        matches_per_day[date_str] = matches_per_day.get(date_str, 0) + 1
    
    if not matches_per_day:
        return "No date data available"
    
    avg_matches_per_day = sum(matches_per_day.values()) / len(matches_per_day)
    remaining_matches = summary.total_matches - summary.completed
    
    if avg_matches_per_day > 0:
        days_remaining = remaining_matches / avg_matches_per_day
        estimated_completion = datetime.now() + timedelta(days=days_remaining)
        
        return f"""Event Duration Estimate:
Remaining matches: {remaining_matches}
Average pace: {avg_matches_per_day:.1f} matches/day
Estimated completion: {estimated_completion.strftime('%Y-%m-%d')}
Days remaining: {days_remaining:.1f}"""
    
    return "Cannot calculate estimate"

print(estimate_event_duration(1189))
```

## Error Handling

<Callout type="info">
This function returns `None` instead of raising exceptions, making it safe to use without try-catch blocks.
</Callout>

- **Network failures**: Returns `None`
- **Invalid event ID**: Returns `None`
- **No matches found**: Returns `None`

Always check if the return value is not `None` before accessing properties.

## Tips

- The `stages` field is currently always an empty list `[]` (reserved for future implementation)
- Use this function for quick event progress overview without fetching all match details
- Combine with `matches()` to get detailed match information after checking the summary
- All count fields (`total_matches`, `completed`, `upcoming`, `ongoing`) are always non-negative integers
- The sum of `completed + upcoming + ongoing` should equal `total_matches`

## Related

<Cards className="mt-2">
  <Card
    href="/docs/api/events/matches"
    title="events.matches()"
    description="Get detailed match information"
    icon={<ListChecks className="h-5 w-5" />}
  />
  <Card
    href="/docs/api/events/info"
    title="events.info()"
    description="Get event header information"
    icon={<Info className="h-5 w-5" />}
  />
  <Card
    href="/docs/api/events/list-events"
    title="events.list_events()"
    description="Browse all events"
    icon={<CalendarSearch className="h-5 w-5" />}
  />
</Cards>

## Source

Data scraped from: `https://www.vlr.gg/event/matches/{event_id}`
